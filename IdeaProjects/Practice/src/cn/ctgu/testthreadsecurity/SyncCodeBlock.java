package cn.ctgu.testthreadsecurity;

/**
 * 根据售票案例简述：
 *    窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等候，窗口1操作结束后，窗口1和窗口2和窗口3才有机会进入代码去执行，
 *    也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象
 * 为了保证每个线程都能正常执行原子操作， Java引入了线程同步机制
 * 有三种方式完成同步操作： 1. 同步代码块  2. 同步方法  3.锁机制
 *
 * 方法一：同步代码块 synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问
 *      格式： synchronized(同步锁) {
 *          需要同步操作的代码
 *      }
 *
 *      同步锁： 对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁
 *      1.锁对象， 可以是任意类型
 *      2.多个线程对象， 要使用同一把锁
 *      注意：在任何时候，最多允许一个线程拥有同步锁，谁先拿到锁谁就进入代码块，其他的线程只能在外边等着
 *
 *
 *   同步技术的原理：
 *      使用了一个锁对象，这个锁对象叫同步锁，也叫对象锁，也叫对象监视器
 *      多个线程一起抢夺CPU的执行权，谁抢到谁执行
 * @author NiuQun
 * @2019/12/31
 */

public class SyncCodeBlock {
    public static void main(String[] args) {

    }
}
